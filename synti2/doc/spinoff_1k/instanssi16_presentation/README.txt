A spinoff project.. Something totally different that doesn't actually
belong here in synti2 repository, but let's call it a "spinoff project
early preview", and it may fit in the doc/ folder...

Assembler experiments of my own, much inspired by Raiter's "teensy
elf" posts and examples. Trying to make a Linux x86_64 framework for
1k intro compos.

Status:

This is an early preview of as-of-yet unpublished codes, to illustrate
a speach I'm giving (in Finnish) at the Instanssi 2016 demo party in
March 2016.

Work of others found in Assembly Computer Festival Archives:

- "Bioterrorism" by Below Absolute Zero seems to be one of the very
  few Linux entries in Assembly 1k intro compo within the last few
  years, placing 7th in 2013:
  http://archive.assembly.org/2013/1k-intro/bioterrorism-by-below-absolute-zero

- Another is "Inconsistency" by "Hymy", which placed 11th in Asm 2013 1k:
  http://archive.assembly.org/2013/1k-intro/inconsistency-by-hymy

- "harsh" by fsqrt & ye olde laptops posse, 13th in Asm 2012 1k:
  http://archive.assembly.org/2012/1k-intro/harsh-by-fsqrt-ye-olde-laptops-posse

- "planB" by yolp, 19th in Asm 2012:
  http://archive.assembly.org/2012/1k-intro/planb-by-yolp


Notes to future self:

- The goal here is to go into the "1k intro" class of making tiny
  executables in the "new old school" of using native machine code
  instead of a browser platform (will do that later, too, probably,
  but there's still more things to learn back in the native land...)

  Linux platform, C language and the GNU toolchain had its limits with
  the overhead generated by the compiler and required by the ELF
  loader, so I wanted to find the more ultimate limits. I looked at
  some ideas in the "teensy elf" examples by Brian Raiter, and here is
  where I have come so far..

- 1k is possible, but probably I won't be able to compete with the
  more modern platforms with all the overhead that can't really be
  avoided. Some of the things in here might be very useful also in the
  4k genre. I hope there will be competitions in 4k in the future,
  too...

I've made a couple of different tries, but only one of them is found here:

* i16example.asm - SDL2, GLSL fragment shader doing all the
  graphics. This stub is actually under 1k, but there is very little
  space for the shader itself.. well, there is some, but not so much..

Others are not yet published.. Stay tuned, though:

* sdlgl.asm - SDL2, OpenGL (legacy) without shaders. This is not at
  all optimized (as of 2015-10-05), so I don't really know how useful
  this branch is. There is basically less overhead because the many
  functions to compile a shader are needed. But then you get only one
  kind of primitive which is painted in default white. All settings of
  color, 3D transformations, perspective, will require their own
  function calls and add to the overhead. It is still unclear to me
  whether the shader-less way contains less overhead than the shader
  way.

* sdlfbonly.asm - SDL2, software rendering to a framebuffer. This stub
  got under 1k too, and the setup overhead might be less than with
  GLSL (must re-check after latest modifications to the GLSL
  version). But I have no idea if meaningful graphics code could be
  done within the few bytes available.. Graphics code is also quite
  tedious to write in native AMD64, so, as of now, I've been happy
  with the GLSL.

Further notes:

* The ELF overhead is now quite minimal; I don't think much more can
  be gained by Raiter's advice or anyone elses existing guides... I'm
  interested to hear if someone has new ideas.

* SDL2 overhead is as small as it can get, too.. smaller executables
  would require a platform with less mandatory init calls.

* GLSL overhead is as small as it can get, unless there are some "load
  and compile all shaders" kind of convenience functions in some
  library that could be used across standard Linuxes.

* It seems that some (small, but many) gains are possible by really
  optimizing for compressibility with gzip.
