;;; da1k6 - back to basics, precomputed sequence with minimal footprint
;;; but with possibility of some nice instrument sounds.
;;; 
;;; VERDICT: These ideas were a no-go - da1k7 produces exact same example song
;;; with 40 bytes less space. Lessons learned in comments below.
;;; 
;;;
;;; Some overall things to try for 1k were:
;;; 
;;; 	(1) precalculate the whole song and let the audio callback do
;;;         just copying. Then the calculation doesn't need to preserve
;;; 	    register contents and all that "ABI crap".. can use RBP and
;;;         RSP as they are set in the main code and no need for those
;;;         frustrating LEAs in the beginning. Also, preservation of
;;;         synth state would not be an issue.. could mix into the middle
;;;         of the output buffer and so on.. This was implemented here,
;;;         likely a good idea, worth holding on to.
;;; 
;;; 	(2) if there is a possibility to sequence a song, it just
;;;         can't be stored in the MIDI-like format that requires conversions
;;;         from tick deltas to frames (and with state also checks when the
;;;         next event is up). Implemented as bit patterns here. Likely not
;;;         such a good idea.. good for drums but not so much for tones.
;;;
;;;     (3) it is time to make a tool program to produce sequence data in a
;;; 	    micro format.. starting to be too convoluted for manual conversion..
;;;         Not yet implemented, since the sequence format should perhaps be
;;;         something else, after all.

;;; Define a couple of parameterless macros that will be expanded
;;; in suitable places of main code (must define each macro, even
;;; if they are empty):
;;; SYNTH_REQUIRED_DEFINES - defines and compiler constants; included before others 
;;; SYNTH_CONSTANT_DATA - constant data to insert in code segment, wherever suitable
;;; SYNTH_PATTERN_DATA - song data. NOTE: This is not part of the synth engine,
;;;   so this should be generated by a tool program and %included in main.
;;;   must define an address called syn_sequence
;;; SYNTH_BSS_DATA - structures to reserve in the BSS section. MUST include
;;;   "synth_frames_done: resq 1" which is used in rendering code (as of now)
;;; SYNTH_INITIALIZATION_CODE - This macro will be inserted in the
;;;   initialization part of the main file. Prepare what is necessary.
;;;   The code will be "inlined", not called as a subroutine. Assume nothing
;;;   pre-initialized - this could be the very first code in the program.
;;; SYNTH_AUDIO_CALLBACK_CODE - must contain a function named
;;;   "audio_callb_sdl" that SDL2 will call to fill audio buf.
;;;   May contain also helper functions, if necessary.

;;; Some notes on the effect of the fundamental minimizations:
;;; - gzipped (gzip -9 without self-extractor) size before optimizations: 1130
;;; - First version of pre-compute-and-copy: 1107 (good improvement)
;;; - Separate arrays for time and note deltas; some micro-optimizations: 1098
;;; - Change the tuning so that the involved float contains 2 zero bytes: 1095
;;; - Bit patterns as the song data (probably not a good idea?): (forgot to measure)
;;; - After optimizing everything for zopfli: 1113 (never mind; zopfli wins it back.)

%include "general_macros.asm"

%macro	SYNTH_REQUIRED_DEFINES 0
	;; Let's make the RNG an optional feature.. can lose those 19-23 bytes if required.
	%define SYN_FEAT_NOISE
	
	;; Tempo as a tick length - could use a value that resembles some necessary opcode.
	%define	SYN_TICKLEN	0x1200

	;; What we would like the callback userdata to be
	%define	SYN_USERDATA_INIT	syn_prerendered_content

	;; Song length (note that gdb will start slowly if very large bss is used):
	%define SYN_SONG_LENGTH_IN_FRAMES	48000*14 ; minimum
	%define SYN_SONG_LENGTH_PAD_TO		0x400000 ; something tolerable?

%endmacro

%macro	SYNTH_CONSTANT_DATA 0
	
syn_constants:			; <--- this is a "base addr"; could vary the location..
syn_c0freq:
;;; 	dd	8.175798915643707      ; C freq (MIDI note 0; standard 440Hz tuning)
;;; 	dd	0.00017032914407591056 ; C freq / sr
;;; 	dd	0.001070209575442236   ; C freq / sr * 2 * pi
	
;;;  	dd	0.0010700226	; a "nearby-value" with compressible repr.
;;;  	dd	0.0010681152
;;;    	dd	9.765625E-4
  	dd	0.001034632	; "nearby-value" almost same bytes as in freqr.
	
syn_freqr:
	dd	1.0594630943592953  ; freq. ratio btw notes (shouldn't tweak much)
	
%ifdef SYN_FEAT_NOISE
syn_rdiv:
;;;  	dd	0x80000000	; proper integer divisor for random number
;;;   	dd	0x3f879c7d	; another option for rand divisor
	;; (which just happens to be identical to the bit representation
	;; of the frequency ratio above.. randoms will be approximately 
	;; in the range [-2,2], though, instead of [-1,1]).
   	dd	0x8c000000	; another option for rand divisor; quiet range

syn_rand:
	dd	0x8c000001	; random seed. Could as well be the same as divisor..
%endif

%endmacro

%macro SYNTH_PATTERN_DATA 0


syn_sequence:
;;; Instrument format for synth version "da1k6":
;;; 4 bits that need to be duplicated in high and low nibble of a byte
;;; abcd abcd : d==Pitch envelope (BD)  c==Mute tone  b==Noise on (SD)  a==unused
;;; Follow by note length as number of ticks (one byte) and note number (byte).
;;; Tuning is "somewhere near and/or around MIDI note values.."
;;; 
;;; Use bit pattern instead of time deltas:
syn_pattern:
	db	0 	      	; ticks before start of this layer
	db	8	      	; nrepeats for this layer
	dd	0x110200 + 20	; note (and possibly instrument params?)
	dd	0x8888888b	; sequence as a bit pattern

	db	32	      	; ticks before start of this layer
	db	8	      	; nrepeats for this layer
	dd	0x440100 + 67	; note (and possibly instrument params?)
	dd	0x08080809	; sequence as a bit pattern
	db	32 	      	; ticks before start of this layer
	db	8	      	; nrepeats for this layer
	dd	0x000200 + 48	; note (and possibly instrument params?)
	dd	0x22250000	; sequence as a bit pattern
	db	32             	; ticks before start of this layer
	db	8	      	; nrepeats for this layer
	dd	0x000200 + 45	; note (and possibly instrument params?)
	dd	0x00002525	; sequence as a bit pattern
	db	0	      	; ticks before start of this layer
	db	0	      	; nrepeats==0 means end of song data

%endmacro

%define SYN_ADDR(reg,base,var) reg + ((var) - base)

%macro	SYNTH_BSS_DATA 0

;;; Can adjust the bss start location to get nicer absolute addresses
TIMES (0x10000-8) + $$ - $	resb	1

synth_frames_done:	resq	1	; Global frame counter (read by main)
syn_prerendered_content:	resb	2*4*(SYN_SONG_LENGTH_IN_FRAMES)
ALIGNB	SYN_SONG_LENGTH_PAD_TO	
%endmacro
	
%macro	SYNTH_AUDIO_CALLBACK_CODE 0
;;; We get userdata in rdi, stream address in rsi, buffer length in rdx.
;;; Userdata points to frame counter, after which there is the pre-rendered content.
;;; (no need to align stack; we call no-one; we don't touch registers.)
	
audio_callb_sdl:

	shr	edx,3
	mov	ecx,edx
	mov	eax, [rdi - (syn_prerendered_content - synth_frames_done)]
	add	dword [rdi - (syn_prerendered_content - synth_frames_done)],edx
	
 	lea	edi, [edi + eax * 4]
	xchg	esi,edi

%%audio_copy_loop:
	;; Multiplex mono to stereo
	lodsd
	stosd
	stosd
 	loop	%%audio_copy_loop

	ret
%endmacro
	
;;; This code will be inlined, but we should preserve callee-saved registers.
;;; Also, we can assume that rbp points to _base1 near constant data, and that
;;; Dynamic libraries have been linked. TODO: These assumptions are
;;; unnecessary?

%macro	SYNTH_INITIALIZATION_CODE 0

;;; Actual init code.
	
%%start_of_synth_init:

;;;  	push	rbp
	push	syn_prerendered_content
	pop	rdi
;;; 	lea	edi,[ABS syn_prerendered_content]
	
	push	syn_constants
	pop	rbp
;;; 	lea	ebp,[syn_constants]
 	lea	esi,[SYN_ADDR(rbp,syn_constants,syn_sequence)]
	
;;; ----------------- Pre-rendering code; inlined in main
;;; Expect: rbp points to syn_constants; rdi to output buffer.
;;; rsi to beginning of sequence data. WE WILL MESS UP RBX!
synth_render_song:
%define SYN_NREPEATS	r8b	; use register for repeat counter

	;; Use edx as output frame index; start each layer at 0:
%%songloop:
;;; 	GPR_LD0	edx		; start mixing from frame 0.
	push	0
	pop	rdx
	lodsb
	GPR_LD0	ecx
	mov	cl,al
%%prewait:
	jrcxz	%%read_layer
	add	edx,SYN_TICKLEN
	loop	%%prewait
%%read_layer:
	lodsb
	mov	byte SYN_NREPEATS,al	; nrepeats
 	cmp	al,0
 	je	%%seq_fini
	
	;; Note and instrument data to stack (will re-use on calls):
	lodsd
	push	rax
	;; Sequence bit pattern to rax:
	lodsd
%%repone:
	;; Loop the 32 bits:
	GPR_LDB	rcx,32
%%tickloop:
	mov	ebx,[rsp]
	rol	eax,1
	jnc	%%tickcontinue
	call	%%mix_note
%%tickcontinue:
	add	edx,SYN_TICKLEN
	loop	%%tickloop

	;; TODO: Decide on end condition.
	dec	byte SYN_NREPEATS
	jnz	%%repone
	pop	rax		; rid of current note
	jmp	%%songloop
%%seq_fini:


	jmp	%%end_ini

	

;;; ------------ produce one note.
	;; Expect rdi == output buffer start rdx == output start frame
	;; Expect BH==tone length; must be at least 1. BL==note.
%%mix_note:
	push	rax
	push	rdi
	push	rdx
 	lea	rdi,[rdi + rdx * 4]

%%compute_frequency:
	;; frequency re-compute. Stack contents in a Forth'ish comment:
	fld	dword [SYN_ADDR(rbp,syn_constants,syn_c0freq)] ; (c0note)
%%freqloop:
;;; To make every byte matter in the gzip phase.. can add nops, but not always:
;;; TIMES 2	nop
	fmul	dword [SYN_ADDR(rbp,syn_constants,syn_freqr)]
 	fnop
	dec	bl
	jnz	%%freqloop
	;; Stack now has (note)
	
	ror	ebx,8
%%compute_length:
	GPR_LD0	eax
%%lenloop:
	add	eax,SYN_TICKLEN
	dec	bl
	jnz	%%lenloop

	ror	ebx,8		; length and note done; then "instrument" in bx

	;; Prepare stack with two copies of note length (in frames):
	push	rax
	push	rax


	;; Loop always starts with the following stack layout: (note)
%%l1:
	;; Downward sloping envelope (1->0). Necessary. Will be in fpstack:
	fild	dword [rsp]	; (note framesleft)
	fidiv	dword [rsp+8]	; (note [framesleft/length =: env])

	fld	st1	   	; (note env note)
	
	;; Multiply pitch by 1+2*env^3 if instrument is like that:
	ror	bl,1
	jnc	%%no_pitch_env
	
	fadd	st0		; (note env (2*note))
	fmul	st1		; (note env (2*env*note))
	fmul	st1		; (note env (2*env^2*note))
	fmul	st1		; (note env (2*env^3*note))
	fadd	st2		; (note env [note+(2*env^3*note) =: finnote]) .. "bassdrummy"
%%no_pitch_env:
	
	;; Multiply frequency by frames_done to get current phase:

	fimul	dword [rsp]	; (note env phase*finnote)
	fsin			; (note env sin(phase*finnote))

	;; Revert to zero if the instrument is like that:
	ror	bl,1
	jnc	%%no_zero_pitch
	fsub	st0		; (note env [(sin(phase*finnote) | 0.0) =: aud] )
%%no_zero_pitch:

	;; Add noise if the instrument is like that:
	;; Random generator seems rather lengthy (30+ bytes compressed..):
	;; 27 total when using register r13 to store seed (nasty xchg needed)
	;; OK.. "only" 24 when using rpb-relative addresses.. depends on the
	;; other bytes in the compressed stream, so might be +/- some. Final
	;; tweaking will likely help always.
%ifdef SYN_FEAT_NOISE
	mov	eax,16807	; multiplier
 	ror	bl,1
 	jnc	%%no_noise	; conditional compresses better here in the middle..
	mul	dword [SYN_ADDR(rbp,syn_constants,syn_rand)]
	mov	dword [SYN_ADDR(rbp,syn_constants,syn_rand)], eax
	fild	dword [SYN_ADDR(rbp,syn_constants,syn_rand)]	; (note env aud cur_randseed)
	fidiv	dword [SYN_ADDR(rbp,syn_constants,syn_rdiv)]	; (note env aud cur_randf)
	faddp	st1					    	; (note env aud+randf)
%%no_noise:
	;; Multiply with the slope envelope. Necessary:
	ror	bl,1
	fmulp	st1  						; (note env*(aud+randf))
%else
	fmulp	st1
	rol	bl,2
%endif

	;; Mix to current pos., and advance
	fadd	dword [rdi]					; (note env*(aud+randf)+old)
	fstp	dword [rdi]					; (note)
	scasd
	
	dec	dword [rsp]
	jnz	%%l1

	;; rid of stack space
	pop	rdx
	pop	rdi
	
	;; actual pops
	pop	rdx
	pop	rdi
	pop	rax
	
 	ret
	
%%end_ini:
	
%endmacro
