;;; da1k8 restricted - Only FM, no code related to noise or instrument parameters!
;;; This is to be optimized for single instrument FM-only kind of tunes when that
;;; suffices. Same tune format can be used here as with da1k7, but instrument params
;;; are not used for anything.

;;; Define a couple of parameterless macros that will be expanded
;;; in suitable places of main code (must define each macro, even
;;; if they are empty):
;;; SYNTH_REQUIRED_DEFINES - defines and compiler constants; included before others 
;;; SYNTH_CONSTANT_DATA - constant data to insert in code segment, wherever suitable
;;; SYNTH_PATTERN_DATA - song data. NOTE: This is not part of the synth engine,
;;;   so this should be generated by a tool program and %included in main.
;;;   must define an address called syn_sequence
;;; SYNTH_BSS_DATA - structures to reserve in the BSS section. MUST include
;;;   "synth_frames_done: resq 1" which is used in rendering code (as of now)
;;; SYNTH_INITIALIZATION_CODE - This macro will be inserted in the
;;;   initialization part of the main file. Prepare what is necessary.
;;;   The code will be "inlined", not called as a subroutine. Assume nothing
;;;   pre-initialized - this could be the very first code in the program.
;;; SYNTH_AUDIO_CALLBACK_CODE - must contain a function named
;;;   "audio_callb_sdl" that SDL2 will call to fill audio buf.
;;;   May contain also helper functions, if necessary.

	
%include "general_macros.asm"

%macro	SYNTH_REQUIRED_DEFINES 0
	;; Let's make the RNG an optional feature.. can lose those 19-23 bytes if required.
	%define SYN_FEAT_NOISE
	;; OK, the pitch envelope is also optional now. Only a couple of bytes.
	%define SYN_FEAT_PITCH_ENVELOPE
	%define SYN_FEAT_FM
	%define SYN_AINT_NO_STEREO

	%define	SYN_END_SEQ	0x75 ; ends both layer and song (invalid as time/note, sry.)
	
	;; Tempo as a tick length - could use a value that resembles some necessary opcode.
	%define	SYN_TICKLEN	0x2400

	;; What we would like the callback userdata to be
	%define	SYN_USERDATA_INIT	syn_prerendered_content

	;; Song length (note that gdb will start slowly if very large bss is used):
	%define SYN_SONG_LENGTH_IN_FRAMES	48000*14 ; minimum
	%define SYN_SONG_LENGTH_PAD_TO		0x400000 ; something tolerable?
%endmacro

%macro	SYNTH_CONSTANT_DATA 0

syn_constants:			; <--- this is a "base addr"; could vary the location..
syn_c0freq:
 	dd	0.001034631	; 0x3a879c75; close to MICI note 0 freq / sr * 2 * pi
syn_freqr:
	dd	1.0594622	; 0x3f879c75; close to 1.0594630943592953
syn_ticklen:
	dd	SYN_TICKLEN
%endmacro

;;;  (Pattern data now taken to its own file.)

%define SYN_ADDR(reg,base,var) reg + ((var) - base)

%macro	SYNTH_BSS_DATA 0

;;; Can adjust the bss start location to get nicer absolute addresses
TIMES (0x10000-8) + $$ - $	resb	1

synth_frames_done:	resq	1	; Global frame counter (read by main)
syn_prerendered_content:	resb	2*4*(SYN_SONG_LENGTH_IN_FRAMES)
ALIGNB	SYN_SONG_LENGTH_PAD_TO	
%endmacro
	
%macro	SYNTH_AUDIO_CALLBACK_CODE 0
;;; We get userdata in rdi, stream address in rsi, buffer length in rdx.
;;; Userdata points to frame counter, after which there is the pre-rendered content.
;;; (no need to align stack; we call no-one; we don't touch registers.)
	
audio_callb_sdl:
	;; As of now, I can't make this any shorter in any way. End of imagination.
	shr	edx,2
	mov	ecx,edx
	
	mov	eax, [rdi - (syn_prerendered_content - synth_frames_done)]
	add	[rdi - (syn_prerendered_content - synth_frames_done)], edx

 	lea	edi, [rdi + rax * 4]
  	xchg	rsi,rdi		; TODO: How likely is the stream addr above 32 bits!?
	
	rep	movsd		; One channel mono output. No loop needed, just rep.

	ret
%endmacro
	
	
;;; --------------------------------------------------------------------------
;;; Synth init. Agreement: Will be the first code in the whole program. Assume
;;; nothing; no need to preserve anything.
;;; --------------------------------------------------------------------------

%macro	SYNTH_INITIALIZATION_CODE 0

;;; Actual init code.
	
%%start_of_synth_init:

;;; Which one to choose? Likely depends on whether push dword repeats later or not:
;;;  	push	syn_prerendered_content
;;;  	pop	rdi
  	mov	edi,syn_prerendered_content ; shorter uncompressed opcodes
	
;;; Different options here, too. Best one likely depends on surrounding code:
;;; 	push	syn_constants
;;; 	pop	rbp
;;;  	lea	ebp,[syn_constants]
	mov	ebp,syn_constants
	
;;;  	mov	esi,syn_sequence
  	lea	esi,[SYN_ADDR(rbp,syn_constants,syn_sequence)]
	

;;; ----------------- Pre-rendering code; inlined in main
;;; Expect: rbp points to syn_constants; rdi to output buffer.
;;; rsi to beginning of sequence data. WE MESS UP RBX AND STACK!
synth_render_song:
	
%%songloop:
	GPR_LD0	eax
	lodsb
	cmp	al,SYN_END_SEQ
	je	%%end_ini
	
	mul	dword [SYN_ADDR(rbp,syn_constants,syn_ticklen)]

	lodsb			; include instrument mix byte
	mov	ebx,eax
  	GPR_LD0	ecx		; start mixing from frame 0.
;;;   	mov	ecx,0
;;; 	GPR_LDB	rcx,0
	
%%read_delta_and_note:
	GPR_LD0	eax
	lodsb
	cmp	al,SYN_END_SEQ
	je	%%songloop
	mul	dword [SYN_ADDR(rbp,syn_constants,syn_ticklen)]
	add	ecx,eax

	lodsb

	%if 0
	;; Some delay mystery
	push	rcx
	push	rax
	push	2

	shl	dword [rsp],1
	mov	rax,[rsp+8]
 	call	%%mix_note
	add	ecx,SYN_TICKLEN
	shl	dword [rsp],1
	add	ecx,SYN_TICKLEN
	shl	dword [rsp],1
	add	ecx,SYN_TICKLEN
	shl	dword [rsp],1
	mov	rax,[rsp+8]
 	call	%%mix_note
	add	ecx,SYN_TICKLEN
	shl	dword [rsp],1
	add	ecx,SYN_TICKLEN
	shl	dword [rsp],1
	add	ecx,SYN_TICKLEN
	shl	dword [rsp],1
	mov	rax,[rsp+8]
 	call	%%mix_note
	
	pop	rcx
	pop	rcx
	pop	rcx
	%else
	push	5
	push	5
	call	%%mix_note
	%endif
	

	jz	%%read_delta_and_note ; Expect ZF set always after mix_note!!


;;; ------------ produce one note.
	;; Expect rdi == output buffer start rcx == output start frame
	;; [rsp+8] == note length in frames BL == instrument bits
	;; AL == note
	;; 
	;; [Old was: Expect BH==tone length; must be at least 1. BL==note.]
%%mix_note:

%%compute_frequency:
	;; frequency re-compute. Stack contents in a Forth'ish comment:
	fld	dword [SYN_ADDR(rbp,syn_constants,syn_c0freq)] ; (c0note)
%%freqloop:
	fmul	dword [SYN_ADDR(rbp,syn_constants,syn_freqr)]
	sub	al,1
	jnz	%%freqloop
	;; Fp stack now has (note)

	push	rdi
	push	rcx
   	lea	edi,[rdi + rcx * 4]

	;; Prepare stack with two copies of note length (in frames):
	push	rbx
	push	rbx


	;; Loop always starts with the following stack layout: (note)
%%l1:
	;; Downward sloping envelope (1->0). Necessary. Will be in fpstack:
	fild	dword [rsp]	; (note framesleft)
	fidiv	dword [rsp+8]	; (note [framesleft/length =: env])

	fld	st1	   	; (note env note)
	
	;; Multiply frequency by frames_done to get current phase:
	fimul	dword [rsp]	; (note env phase*finnote)

	;; Always apply FM
	fld	st0		; (note env phase*finnote phase*finnote)
	fadd	st0
	fsin			; (note env phase*finnote sin(2*phase*finnote))
;;;  	fadd	st0
;;;  	fadd	st0
	fld	st3
	fadd	st0
	fadd	st0
	fadd	st0
	fadd	st0
	fdivp 	st1

	fmul	st2		; (note env phase*finnote env*sin(phase*finnote))
	faddp			; (note env phase*finnote+env*sin(phase*finnote))
	fsin			; (note env sin(phase*finnote))

	;; Multiply with the slope envelope. Necessary:
	fmulp	st1  		; (note env*(aud+randf))

	fidiv	dword [rsp+40]	; volume divisor from stack
	;; Mix to current pos., and advance
	fadd	dword [rdi]					; (note env*(aud+randf)+old)
	fstp	dword [rdi]					; (note)
	scasd
	
	dec	dword [rsp]
	jnz	%%l1

	;; rid of stack space
	pop	rdi
	pop	rdi
	
	;; actual pops
	pop	rcx
	pop	rdi

 	ret
	
%%end_ini:

	
%endmacro
