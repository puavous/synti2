import sys, string, re, math

data = []
for L in sys.stdin.readlines():
    if L[0] == '#':   continue
    if L[0] == '^':   break
    if not L.strip(): continue

    nums = map(string.strip, re.split("\s+",L.strip()))
    data += map(float, nums);

def sign(val):
    if (val < 0.0): return -1.0
    return 1.0

def synti2_encode(val):
    sg = sign(val)
    ab = abs(val)

    # Accuracy is .001 (adjust 0.000 - 0.009
    permill = int(ab * 1000)
    fine_nib = permill % 10
    permill /= 10

    # Usual range is 0.0 to 1.0
    low_byte = permill % 100
    permill -= low_byte
    # hack the final +1 to include 1.0 instead of 0.99
    if permill > 0 and low_byte==99:
        low_byte = 100
        permill -= 100
    permill /= 100

    # Then can have additional 0..99
    mid_byte = permill % 100
    permill /= 100

    # And can have additional 0..99 * 100
    high_byte = permill % 100
    permill /= 100

    if permill > 0:
        print "Too big absolute value to be stored %.17f"%val
        exit(1)

    # Maybe there is a sign.
    if (sg == -1): sign_niblet = 0x4
    else: sign_niblet = 0x0

    adjust_byte = sign_niblet * 0x10 + fine_nib

#    print "(%d %d %d %d) %.17f"%(low_byte, 
#                                 mid_byte, 
#                                 high_byte, adjust_byte, val)
    return (low_byte, mid_byte, high_byte, adjust_byte)


length = len(data)
buflen = length*4+9

if length >= 2**14:
  print "Too long message (length=%d)!"%length
  exit(1)

towrite = map(synti2_encode, data)

stride1 = ""
stride2 = ""
stride3 = ""
stride4 = ""
for (a,b,c,d) in towrite:
    stride1 += "0x%02x, "%(a)
    stride2 += "0x%02x, "%(b)
    stride3 += "0x%02x, "%(c)
    stride4 += "0x%02x, "%(d)


print "/* Autogenerated .. may or may not be compatible today :) */"
print "/* Contents in (more or less) human-readable form:"
print repr(data)
print "*/"
print "int hack_patch_sysex_length = %d;  /* %d values + header */ "%(buflen,length)
print "unsigned char hack_patch_sysex[%d] = {"%(buflen)
print "  0xf0, 0x00, 0x00, 0x00, /* zeros in place of manufacturer ID */"
print "  0x00, 0x00, /* 14bit address */"
print "  0x%02x, 0x%02x, /* 14bit length/stride */ "%(length/0x80, length%0x80)
print "  " + stride1
print "  " + stride2
print "  " + stride3
print "  " + stride4
print "  0xf7};"
