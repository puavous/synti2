import sys, string, re, math

def sign(val):
    if (val < 0.0): return -1.0
    return 1.0

def synti2_encodef(val):
    sg = sign(val)
    ab = abs(val)

    # Accuracy is .001 (adjust 0.000 - 0.009
    permill = int(ab * 1000)
    fine_nib = permill % 10
    permill /= 10

    # Usual range is 0.0 to 1.0
    low_byte = permill % 100
    permill -= low_byte
    # hack the final +1 to include 1.0 instead of 0.99
    if permill > 0 and low_byte==99:
        low_byte = 100
        permill -= 100
    permill /= 100

    # Then can have additional 0..99
    mid_byte = permill % 100
    permill /= 100

    # And can have additional 0..99 * 100
    high_byte = permill % 100
    permill /= 100

    if permill > 0:
        print "Too big absolute value to be stored %.17f"%val
        exit(1)

    # Maybe there is a sign.
    if (sg == -1): sign_niblet = 0x4
    else: sign_niblet = 0x0

    adjust_byte = sign_niblet * 0x10 + fine_nib

#    print "(%d %d %d %d) %.17f"%(low_byte, 
#                                 mid_byte, 
#                                 high_byte, adjust_byte, val)
    return (low_byte, mid_byte, high_byte, adjust_byte)

def synti2_encode3s(L):
    res = []
    for i in map(lambda a: 2*a, range(len(L)/2)):
        res.append(((int(L[i])<<3) + (int(L[i+1]))))
    return res

def synti2_encode7(val):
    return int(val)


#length = len(data)
#buflen = length*4+9

data = []
for L in sys.stdin.readlines():
    if L[0] == '#':   continue
    if L[0] == '^':   break
    if not L.strip(): continue

    nums = map(string.strip, re.split("\s+",L.strip()))
    data += map(float, nums)


#if length >= 2**14:
#  print "Too long message (length=%d)!"%length
#  exit(1)


# FIXME Hardcoded:
int3_data = data[0:16]
int7_data = data[16:32]
float_data = data[32:(32+128)]
totlen = 9+16+16+(4*128)


int3_to_write = synti2_encode3s(int3_data)
int7_to_write = map(synti2_encode7, int7_data)
floats_to_write = map(synti2_encodef, float_data)

i3str = string.join(map(lambda v: "0x%02x, "%v, int3_to_write))
i7str = string.join(map(lambda v: "0x%02x, "%v, int7_to_write))

stride1 = ""
stride2 = ""
stride3 = ""
stride4 = ""
for (a,b,c,d) in floats_to_write:
    stride1 += "0x%02x, "%(a)
    stride2 += "0x%02x, "%(b)
    stride3 += "0x%02x, "%(c)
    stride4 += "0x%02x, "%(d)

print "/* Autogenerated .. may or may not be compatible today :) */"
print "/* Contents in (more or less) human-readable form:"
print repr(data)
print "*/"
#print "int hack_patch_sysex_length = %d;  /* %d values + header */ "%(buflen,length)
#print "unsigned char hack_patch_sysex[%d] = {"%(buflen)
print "unsigned char hack_patch_sysex[%d] = {"%(totlen)
print "  0xf0, 0x00, 0x00, 0x00, /* zeros in place of manufacturer ID */"
print "  0x00, 0x00, /* 14bit operation code */"
print "  0x00, 0x00, /* 14bit address /location indicator */"
#print "  0x%02x, 0x%02x, /* 14bit length/stride */ "%(length/0x80, length%0x80)
print "  " + i3str
print "  " + i7str
print "  " + stride1
print "  " + stride2
print "  " + stride3
print "  " + stride4
print "  0xf7};"
