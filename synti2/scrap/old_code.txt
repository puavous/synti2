Old Makefile parts:

tinyplayer: $(TINYPLAYERDEPS) Makefile
	$(CC) $(HCFLAGS) $(ARCHFLAGS) -o $@.unstripped.payload \
		-combine -fwhole-program -flto \
		-Iinclude \
		-DULTRASMALL -nostdlib  -nostartfiles -lc \
		$(filter %.c, $(TINYPLAYERDEPS)) \
		$(ARCHLIBS)

	cp $@.unstripped.payload $@.payload 
	$(ARCHSTRIP) $(ARCHSTRIPOPT) $@.payload
	7za a -tgzip -mx=9 tmp.gz $@.payload
	cat tests/selfextr.stub tmp.gz > $@
	rm tmp.gz
	chmod ugo+x $@



tinytest: $(SDLTESTDEPS) tests/selfextr.stub Makefile
# hacking
#
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) `sdl-config --cflags` -c -o sdltest.o sdltest.c 
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) -c -o synti2.o synti2.c
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) -c -o testdata.o testdata.c
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) -c -o teh4k_gfx.o teh4k_gfx.c

#	$(CC) $(ARCHFLAGS) -o $@.unstripped.payload sdltest.o synti2.o testdata.o \
		teh4k_gfx.o \
	   -nostartfiles $(LIBS)

	$(CC) $(HCFLAGS) $(ARCHFLAGS) -o $@.unstripped.payload \
		-combine -fwhole-program -flto \
		-Iinclude \
		-DULTRASMALL -nostdlib  -nostartfiles -lc \
		$(filter %.c, $(SDLTESTDEPS)) \
		$(ARCHLIBS)

# Why do I get problems with these and -m32:
# `sdl-config --libs` -lm -lGL -lGLU


#	$(CC) $(ARCHFLAGS) -o $@.unstripped.payload sdltest.o synti2.o testdata.o \
#		teh4k_gfx.o \
#	   -nostartfiles `sdl-config --libs` -lm -lGL -lGLU

#	strip $(STRIPOPT) -o $@.payload $@.unstripped.payload
#	cat selfextr.stub > $@
#	gzip -n9 <$@.payload >> $@

# I got a 32-bit sstrip executable from Zipola :).  The zipped result
# got from 4.3k down to 3.8k by compiling with -m32 and linking
# against 32bit libraries, using 7zip, and stripping with sstrip
# instead of strip:
	cp $@.unstripped.payload $@.payload 

	$(ARCHSTRIP) $(ARCHSTRIPOPT) $@.payload

	7za a -tgzip -mx=9 tmp.gz $@.payload
	cat tests/selfextr.stub tmp.gz > $@
	rm tmp.gz

	chmod ugo+x $@


sdltest: $(SDLTESTDEPS) Makefile
	$(CC) $(CFLAGS) -o $@ -Iinclude \
		$(filter %.c , $(SDLTESTDEPS)) \
	   `sdl-config --cflags --libs` -lm -lGL -lGLU




Old snippets whose function was moved away from the core engine are
kept here, for purposes of reflection...

  /* The parts. Sixteen as in the MIDI standard. TODO: Could have more? */
  /* FIXME: Remove for good:
     int partofvoice[NVOICES]; */ /* which part has triggered each "voice";
                                -1 (should we use zero instead?) means
                                that the voice is free to re-occupy. */

  /* FIXME: Remove this, too:
     synti2_patch *patchofvoice[NVOICES];*/  /* which patch is sounding; */

  //synti2_part part[NPARTS];   /* FIXME: I want to call this channel!!!*/





  /* note on */

  /* FIXME: Unimplemented plan: if patch is monophonic, always use the
   * voice corresponding to the part number. Otherwise, if that
   * primary voice is occupied, find a free voice starting from index
   * 17. This way, there is always one voice available per channel for
   * mono patches, and it will become more deterministic to know where
   * things happen, for possible visualization needs (but there is
   * evil resource wasting when the song uses less than 16 parts!
   * maybe some kind of free voice stack could be implemented with not
   * too much code...)
   */
  for(voice=0; voice < NVOICES-1; voice++){
    if (s->partofvoice[voice] < 0) break;
  }
  /*if (voice==NVOICES) return;*/ /* Cannot play new note! */
  /* (Could actually force the last voice to play anyway!?) */
