Old contemplations of formats and stuff..
-----------------------------------------

About to be done.. 

# FIXME: It would be perfect if the whole patch design could be partly
# compiled when some "NO_DONT_USE_SOME_FEATURE" is present. That would
# reduce sound data size greatly, I believe! But then there would be a
# problem with tool programs that are using indices at the
# moment. Maybe yet another job for the midi filter module... Map from
# original indices to restricted ones in compose mode? In playback
# mode the code contains only macro names. Yep. Do this somehow!!
#
# ... but then.. yet another new idea emerges, which conflicts with 
# the previous one.
#
# After all, maybe I'll create this design file programmatically..

# FIXME: A small C-like example of what I want here:
#        Resolution: Do the precompilation first, and then generate only
#        the parameters that are actually used in the remaining source!
#        WARNING: Be careful with "SYNTI2_F_DLEV1+id" and the like!
# (but what about during compose-time?)
#ifndef NO_EXTRA_WAVETABLES
HARM1 Op1Wav 0 7   0 5
HARM2 Op2Wav 0 7   0 5
HARM3 Op3Wav 0 7   0 5
HARM4 Op4Wav 0 7   0 5
#endif

Letting go of some things:

/* Total number of "counters", i.e., oscillators/operators. */
/* #define NCOUNTERS (NPARTS * NOSCILLATORS) */

/* Total number of envelopes. There is the magical "zero-envelope"
 * which is technically not operational. Hmm.. 
 *
 * TODO: Is the zero-envelope needed anymore, when we are actually
 * using separate operator gains? It seems to be necessary only for
 * pitch envelopes. Would it make a shorter code if we used a "pitch
 * gain" and not use a zero-envelope?
 */
/* #define NENVS (NPARTS * (NENVPERVOICE+1)) */





      /* NOTE: There will be a value jump here [in the envelope code],
         so be careful when creating patches... The reason for this
         whole thing was to make it possible to use less knees, if 5
         knees is not necessary. As an after-thought, the whole
         envelope thing could have been made with less glitches, but
         that remains as a to-do for some later project. This envelope
         skip-and-jump is now a final feature of synti2. Sorry for the
         pops you get if using this as patch size optimization.  It is
         an unfortunate mis-feature.
       */


      /* The loop logic seems to yield 55 bytes of compressed code!!
       * Whyyy so much?  Hmm... the address computation becomes
       * filthy long. FIXME: Consider some tricks? Pre-computation?
       * Re-ordering of storage?

       * ... no ... Any fix to this went totally beyond me, at least
       * during this project. After some spying, it turned out that
       * the code bloat didn't come only from the envelope logic, but
       * from the fact that the couple of extra variables used would
       * somehow force things in and out of registers in the whole
       * outer loop (the thing is inlined, and things happen all
       * around) and the size-optimizer can't keep pace. If you want
       * looping envelopes in this synthesizer, you pay for the weight
       * in executable size or fix this issue. I won't.

       */


    /* [Old oscillator code]:
     * Linear interpolation using pre-computed "fall" and "rise"
     * tables. Also, the oscillator phases will be the rise values.
     * Phew.. shaved off a byte by letting go of "fall" table...
     * And finally, let go of the "rise" table as well. Performance
     * showed no noticeable change.
     */


     * TODO: See if there was a significant performance hit (?).
       ... Naah, performance is not of priority. Size is.

      /* TODO: If noise was a wavetable like other oscillators, it
       * would not require additional code here. But elsewhere it
       * would.. worth trying or not? Probably not.
       */


      /* TODO: (In a later project!) Need logic for skipping an
         "unsounding channel"? Yes, an #ifndef NO_SKIP_DEAD but then
         what is the rule? op4amp?  how about delay tricks then? */ /*
         I think the following neverhappen was an early placeholder
         for such... */ /* if (pat==NULL) continue; */

      /* TODO: (in a later project) Table lookup for velocity
       * sensitivity? Now just linear velocity sensitivity,
       * although tools could map it nonlinearly.
       *
       * Overall, wavetables could be used much more creatively than they
       * were in this synth (at least oscillators, velocity, envelopes).
       */


    /* TODO: Compare size and speed with zeroing the whole buffer by
       memset prior to synthesis. Did.. larger code with using
       memset.. So I'll just empty the buffer just prior to writing a
       frame.*/

    /* FIXME: See if size could be improved by precomputed iframeL, iframeR 
       Saw: Not really... size (maybe even the code itself?) is the same as
       when using buffer[2*iframe+1] for right channel. */


 * FIXME: (depends: CC ramps) Now that I'm using an internal event
 * format in any case, could I fix the length? Yes, I could... but
 * would that be useful??  there are not so many different messages,
 * and the bulk data message (which is the only variable-length event)
 * could contain a native pointer to a memory area... maybe? This
 * issue needs to be attended while looking at the tool programs as
 * well, and after the implementation of controller ramps is finished,
 * since that probably dictates the maximum length of event data.


/* Some tentative inline assembler for i387 sin. No immediate size
 * improvements were gained. I would still like to try this path, but
 * then more than just the sine instruction should be done with
 * assembly, and maybe the actual improvement would come from absolutely
 * letting go of -lm, which would require bigger changes than what I'm
 * prepared for, at the moment.
 */
#if 0
static
float asm_sin(float t){
  float result;
  asm(
    "fld %1\n"
    "fsin\n"
    "fstp %0\n"
    : "=m"(result)
    : "m"(t)
      );
  return result;
}
#endif
  int sr;           /* Sample rate. */



# As of now (2012-04-11), the sound algorithm is finally almost
# finished for synti2. Only some things related to stereo panning and
# delay effect routing is still lacking from the original plan/dream. 
# And then some other things... but not too many changes anyway.
#
#
# Global data (to be planned)
#   TODO: *Can we use the same int3/int7/float -structure for global data
#         and for patches. Simplifies reader maybe.. "Patch 0"== global
#
#   Ideas:
#
#   Patch selection on each channel/part (range 0-127?)?:
#   0   0   0   0   0   0   0   0   0   0 
#   0   0   0   0   0   0
#
#   Could be done with normal program change messages!?
#     --> Yes, and the "midi filter module" would intercept this, 
#         if somebody

# Mixer section? --> No.. There is now a MIX_LEVEL per patch.
#  (It is just a GUI issue if this feature is needed)
# Volume -> Mix
# 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
# 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0

# Volume -> Effect1  --> No.. There are no special effects in synti2
# 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
# 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0

# Volume -> Effect2  --> No.. There are no special effects in synti2
# 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
# 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0

# Pan?  --> No.. There is now a pan parameter per patch.
#  (It is just a GUI issue if this feature is needed)
# 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
# 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0

# Global parameters would be something like:
#  Delay1                       Delay2
#  length  feedback  LPcutoff   length  feedback  LPcutoff

# Or... should the effects be abstracted as "imaginary part 17" etc.?
#   Could be, of course! 
#   But for now, let us just use some of the MIDI channels for these




# TODO: Think if there should be a "global envelope bank"? Noo.. would
# be too different from a "usual synth interface" which I want to aim
# at (in addition to any other goals).. Maybe in a later project(!).

# [Regarding velocity sensitivity]:
#
# Think about using some look-up tables to their full
# capacity here... 0=no 1=linear 2=squared 3=inverse ...
# (In a later project)
# FIXME: There should be an assignable velocity target and range?
# And hey, with a quite similar logic, a pitch sensitivity could be built?


# Other patch data.. Hmm.. playground as of now:

# Pitch note follow ratio (TODO: Useful?) Not using this
# so-far.. could be nice for tom sounds, spezial effects, or for
# including noise as yet another wavetable.  Hmm. What about... "Skip
# freq" I3 parameter per oscillator. Then noise could be a wavetable
# and the frequency would be set at 1/sr. FIXME: think about this,
# maybe
#
# This was implemented but not per operator.

#PF1 Oper1NoteFollow 0 1   2 15
#PF2 Oper2NoteFollow 0 1   2 15
#PF3 Oper3NoteFollow 0 1   2 15
#PF4 Oper4NoteFollow 0 1   2 15

Related: (FIXME: could/should use wavetable for noise? Should try..)
 No.. not going to try for synti2.. other more important features are
 there. Or maybe yet.. hmm.. let's see.


 * DONE: Controllers would sound nicer if they were clamping counters
 * (no artefacts from discrete value jumps)
 *

Upon leaving the two different layer types..

    /* FIXME: (depends: CC ramps) In fact, if NO_CC is used, then
     * notes are the only layer type.. Could optimize away the whole
     * layer byte in that case, maybe... but then again, that might be
     * just too much optimization... Yep; it is... Ramps are a major
     * element which I rarely want disabled anyway!
     */


#ifndef NO_SYSEX_RECEIVE
    } else if (midibuf[0] == MISSS_MSG_DATA){
      /* Receiving SysEx is nice, but not strictly necessary if the
       * initial patch data is given upon creation.
       */
      synti2_do_receiveData(s, midibuf+1);
#endif

 * FIXME: The sysex_receive() could be hardwired to receive all the
 * patches at once (when compiled as stand-alone), starting from 0,
 * saving the bytes for the offset handling.
 *


/*
 * Misss data format ideas 
 * (Old, deprecated, banished)
 *
 * <songheader> <layer>+
 * <layer> = <layerheader> <layerdata>
 * <layerheader> = <length> <tickmultiplier> <type> <part#> <parameters>
 * <layerdata> = <event>+
 * <event> = <delta><byte>+
 *
 * ... more or less so... and... 
 *
 * Types of layers:
 *
 *  [- 0x8 note off
 *        <delta>  -- maybe unnecessary if using vel=0 for note off!]
 *  - 0x9 note on with variable velocity
 *        <delta><note#><velocity>
 *  - 0x1 note on with constant velocity (given as a parameter)
 *        (note off encoded as on with constant velocity==0)
 *        <delta><note#>
 *  - 0x2 note on with constant pitch (given as a parameter)
 *        <delta><velocity>
 *  - 0x3 note on with constant pitch and velocity (given as parameters)
 *        <delta>
 *
 *  OR... TODO: think if note on and note velocity could be separated?
 *              suppose they could.. could have accented beats and
 *              velocity ramps with little-ish overhead?
 *
 *  - 0xB controller instantaneous
 *        <delta><value>
 *  - 0x4 controller ramp from-to/during
 *        <delta><value1><delta2><value2>
 *  [- 0x5 pitch bend ramp from-to/during (or re-use controller ramp?
 *        DEFINITELY! because our values can be var-length which is 
 *        very natural for pitch bend MSB when needed..)
 *        <delta><bend1><delta2><bend2>]
 *  - 0xf sysex
 *        <delta><sysex>
 *
 *  - 0x6 0x7 0xA 0xC 0xD 0xE reserved. 0x5 probably too.
 *    Maybe could use the 4th bit of type nibble for something else?
 *
 *  Type and part fit in one byte.
 */



The design specification of MisssChunk classes (to be replaced with
proper documentation):
  // Something like this for creation;
  //void from_midi_song_using_translator(MidiSong &s, MidiTranslator &mt);
  // maybe sniff_note_ons_from_channel(MidiSong &s, MidiTranslator &mt, chan);
  /* Or maybe in OOP style just something like:

     setAcceptChn(12);   <- superclass
     Type("Note on"),  <- subclass, actually maybe class MisssNoteChunk
     setNoteAcceptRange("1..32"); <- in MisssNoteChunk only
     setConstantNote(24); <- in MisssNoteChunk!! Wow! THIS determines subtype
     setConstantNote(-1); <- in MisssNoteChunk!! becomes other subtype..
     setConstantVel(100); <- in MisssNoteChunk!! Wow! THIS determines subtype
     setVelAcceptRange(90,110); <- in MisssNoteChunk! THIS is the decimation!
     setVelAcceptRange(1,127); <- and THIS is "no note off" subtype!

     setAcceptController(32); <- in MisssRampChunk only
     setOutputRange(0.0, 1.27); <- in MisssRampChunk only

     Then play back once through translator and each chunk goes
     sniffing for their respective food:

     for each chunk:
       if (chunk.eat_if_tasty(midievent)) break;

     Then MisssRampChunk could have nice algorithms for ramp
     determination, and MisssBulkChunk would be just another, simpler,
     subclass. 

       rampchunk.setDelta() <- THIS is the generative delta which fits
       in the two-byte parameters. OH NO! It doesn't.. need a third
       byte (maybe.. think!) But there could be three for this chunk
       and still only two for the others. It's only an if and add in
       the exe anyway.

       rampchunk.setExaminationTime() <- parameters for the linear
       approximation can be set like this.

     MisssChunk could be a virtual superclass, and Misss file creation
     would become just a matter of building a chunk list from a GUI
     button callback. Oh, but it needs to be serializable. So all
     these will have constructors with a string parameter:

       MisssNoteChunk nc1("Chn: 1 VelRange: 1 127 DefVel: -1 DefNote: -1");
       MisssNoteChunk nc2("Chn: 2 VelRange: 0 127 DefVel: -1 DefNote: -1");
       MisssNoteChunk nc3("Chn: 1 VelRange: 0 0 DefVel: 0 DefNote: -1");

     YES!! Do exactly this. FIXME: asap!!!
  */
  // or something like: from_midi_song_picking_only("chn 1 note on");


The old inner loop thingy:

/* Number of inner loop iterations (audio frame evaluations) between
 * evaluating "slow-motion stuff" such as MIDI input and
 * envelopes. Must be a divisor of the buffer length. Example: 48000/8
 * would yield 6000 Hz (or faster than midi wire rate) responsiveness.
 * Hmm.. there is an audible problem with "jagged volume" (producing a
 * pitched artefact) if the amplitude envelope is outside of the inner
 * loop... So I'll keep at least the envelope progression counter code
 * inside. Same must be true for panning which is essentially an amplitude
 * env. Could it be that pitch or filter envelopes could be outside?
 * TODO: test..
 *
 * As a second thought, I finally think that for 4k/tiny stuff it
 * would be best to not separate the inner loop at all. The
 * performance hit could be compensated by other means in composition
 * mode, and in playback mode we can have a longer output buffer in
 * any case. So the actual to-do is to merge the inner loop to the
 * outer one, maintaining real-time capacity in composition mode.
 */
#define NINNERLOOP 1

	
Some passing thoughts about the filter:

  /* FIXME: Could there be a nicer filter? No. This is nice for synti2.
   *
   * FIXME: The computation becomes unstable with some combinations of
   * cutoff and resonance. Does it really? When? Is it a problem?
   *
   * FIXME: Filter frequency should be given as a midi note actually..
   *        Maybe go back to note2freq, or make another for filter
   *        purposes...  yep, maybe that would do.. compile that part
   *        only if filter is needed.
   */



The old MISSS spec:

/** MISSS - Midi-like interface for Synti2 Software Synthesizer.
 *
 * This program reads and analyzes a standard MIDI file (type 0 or
 * type 1), tries to mutilate it in various ways to reduce its size,
 * and outputs a file compatible with the super-simplistic sequencer
 * part of the Synti2 Software Synthesizer.
 *
 * FIXME: I want to redo this with some more flexible programming
 * language.. (DONE: used C++)
 *
 * Ideas:
 *
 * + Trash all events that Synti2 doesn't handle.
 *
 * + Use simplistic note-off (not going to use note-off velocity)
 *
 * + Make exactly one "track" - call it "layer"! - per one MIDI status
 *   word, use the channel nibble of the status byte for something
 *   more useful (which is? Could be "chord size", i.e., number of
 *   instantaneous notes, no need for zero delta!), and write
 *   everything as "running status". Make a very simple layering
 *   algorithm to piece it together upon sequencer creation. Just "for
 *   layer in layers do song.addlayer(layer)" and then start
 *   playing. Will be very simple at that point.
 *
 * + Trash header information that Synti2 doesn't need.
 *
 * + Only one BPM value allowed throughout the song; no tempo map,
 *   sry. (No need to compute much during the playback).
 *
 * + Use lower parts-per-quarter setting, and quantize notes as
 *   needed. The variable-length delta idea is useful as it is.
 *   FIXME: Could I re-use the var-length decoder for the patches???
 *   I think I could, somehow... if I just figured out how...
 *
 * - Decimate velocities
 *
 * - Approximate controllers with linear ramps.
 *
 * - Turn percussion tracks to binary beat patterns(?).
 *
 * - Observe: Percussive instruments need no note-off.
 *
 */


In the old comment of receiveSysEx()...

/** FIXME: Think about data model.. aim at maximal
    sparsity/compressibility but sufficient expressive range. If it
    turns out that the 1/1000 accuracy is very seldom required, then
    it could be worthwhile to store everything in the much simpler
    format of 4*7 = 28-bit signed integer representing (decimal)
    hundredths. Even then most parameters would only have the
    least-significant 7bit set?

    FIXME: If the song sequence data is finally read from SMF, then
    there will already be a subroutine that reads variable length
    values (the time deltas) which could be re-used here. But what
    about accuracy then?

    FIXME: Think about nonlinear parameter range. For example x^2 -
    usually accuracy is critical for the smaller parameter values. But
    no... pitch envelopes need to be accurate on a wide range!!

    FIXME: Think about the following format:

            high       low
      bits: 000 0000   000 0000
            ||| ||||   |
            ||| ||||   initial value, 7 bits, range 0.000 to 0.127
            ||| ||additional 2 bits? -> integer range 0..511
            ||| ||TODO: could have a third bit? range 0..1024! Wow!
            ||| ||
            ||times to multiply by 10 (range -1270k to +1270; acc. 10000)
            |reserved FIXME: no need to reserve! 
            sign

      examples of usual bit patterns:
            000 0000   000 0001   == 0.001
            100 0000   000 0001   == -0.001
            000 0100   110 0100   == 1.00
            000 0100   000 0000   == 0.00


    SysEx format (planned; FIXME: implement!) 

    F0 00 00 00 [storeAddrMSB] [storeAddrLSB] [inputLengthMSB] [inputLengthLSB]
    ... data LLSBs... 
    ... data LMSBs... 
    ... data MLSBs... 
    ... data MMSBs... 
    F7

    Length is also the stride for value encoding.
**/

Old code for 2-byte F pars:

  //for (c=((a & 0x0c) >> 2); c < 3; c++) decoded *= .1f; /* e-N; N=0..2) */
  //for (c=0; c < ((a & 0x0c) >> 2); c++) decoded *= .1f; /* can be more */
  //decoded *= .001f;                           /* default e-3 */
  //for (c=0; c < ((a & 0x0c) >> 2); c++) decoded *= 10.f; /* can be more */
  /*use of powf() seems to yield longer exe..*/
  /*decoded *= powf(10.f, ((a & 0x0c) >> 2)-3);*/
  /*pat->fpar[ir] = decoded * powf(10.f, ((a & 0x0c) >> 2)-3.f);*/


Old text from the sysex receive function:

 * FIXME: This is not visible to the outside, so the 7 bit restriction
 * from the MIDI sysex world is not necessary if the 8th bit can be
 * used for something more useful. Native types should be used. NOTE:
 * The 7bit restriction is as invalid for all the other parts of the
 * synth core, now that the MIDI interface is banished from here. And
 * thus the 3bit parameters could be extended to as much as 4 bits?
 * Only case when SysEx-type of information would be embedded in a
 * composition is a (non-4k) executable song that would like to
 * extend sound features by reassigning something in a patch while the
 * song is playing. Could synti2 live with disallowing such activity?
 * I start to believe that yes, it could and should disallow
 * non-compose SysEx. One more issue: What about non-restricted
 * executable music, though?

 * FIXME: Verify the necessity of this function. There will be the
 * MIDI translator module in any case, so see if it could deal
 * directly with handleInput(). Fixing this issue requires to
 * simultaneously look at the sound editor and maybe other tool
 * programs.
 *

From the event addition function:

 * FIXME: Hmm. the cause of the editor crash problem just evaded me
 * again. Out of space on this side? Shallow copy unthought-of
 * (hmm. THAT is unchecked as of yet!!)?  Well.. I checked this, and
 * the shallow copy was OK here, because the (as of now, two) callers
 * were careful in allocating space from the synthesizers data pool.



Old Makefile parts:
-------------------

tinyplayer: $(TINYPLAYERDEPS) Makefile
	$(CC) $(HCFLAGS) $(ARCHFLAGS) -o $@.unstripped.payload \
		-combine -fwhole-program -flto \
		-Iinclude \
		-DULTRASMALL -nostdlib  -nostartfiles -lc \
		$(filter %.c, $(TINYPLAYERDEPS)) \
		$(ARCHLIBS)

	cp $@.unstripped.payload $@.payload 
	$(ARCHSTRIP) $(ARCHSTRIPOPT) $@.payload
	7za a -tgzip -mx=9 tmp.gz $@.payload
	cat tests/selfextr.stub tmp.gz > $@
	rm tmp.gz
	chmod ugo+x $@

# For some reason at least -msse4 seems to shave bytes.. so it is
# worthwhile to keep the following memories. I used the following the
# last time.. but there were some stability problems with the compo
# machine...

# -fno-strict-aliasing \
#          -ffast-math -fomit-frame-pointer \
#	  -fpredictive-commoning \
#          --param max-unroll-times=0 \
#          --param max-unrolled-insns=0 \
#          -msse4 -mavx -mhard-float 


tinytest: $(SDLTESTDEPS) tests/selfextr.stub Makefile
# hacking
#
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) `sdl-config --cflags` -c -o sdltest.o sdltest.c 
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) -c -o synti2.o synti2.c
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) -c -o testdata.o testdata.c
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) -c -o teh4k_gfx.o teh4k_gfx.c

#	$(CC) $(ARCHFLAGS) -o $@.unstripped.payload sdltest.o synti2.o testdata.o \
		teh4k_gfx.o \
	   -nostartfiles $(LIBS)

	$(CC) $(HCFLAGS) $(ARCHFLAGS) -o $@.unstripped.payload \
		-combine -fwhole-program -flto \
		-Iinclude \
		-DULTRASMALL -nostdlib  -nostartfiles -lc \
		$(filter %.c, $(SDLTESTDEPS)) \
		$(ARCHLIBS)

# Why do I get problems with these and -m32:
# `sdl-config --libs` -lm -lGL -lGLU


#	$(CC) $(ARCHFLAGS) -o $@.unstripped.payload sdltest.o synti2.o testdata.o \
#		teh4k_gfx.o \
#	   -nostartfiles `sdl-config --libs` -lm -lGL -lGLU

#	strip $(STRIPOPT) -o $@.payload $@.unstripped.payload
#	cat selfextr.stub > $@
#	gzip -n9 <$@.payload >> $@

# I got a 32-bit sstrip executable from Zipola :).  The zipped result
# got from 4.3k down to 3.8k by compiling with -m32 and linking
# against 32bit libraries, using 7zip, and stripping with sstrip
# instead of strip:
	cp $@.unstripped.payload $@.payload 

	$(ARCHSTRIP) $(ARCHSTRIPOPT) $@.payload

	7za a -tgzip -mx=9 tmp.gz $@.payload
	cat tests/selfextr.stub tmp.gz > $@
	rm tmp.gz

	chmod ugo+x $@


sdltest: $(SDLTESTDEPS) Makefile
	$(CC) $(CFLAGS) -o $@ -Iinclude \
		$(filter %.c , $(SDLTESTDEPS)) \
	   `sdl-config --cflags --libs` -lm -lGL -lGLU




Old snippets whose function was moved away from the core engine are
kept here, for purposes of reflection...

  /* The parts. Sixteen as in the MIDI standard. TODO: Could have more? */
  /* FIXME: Remove for good:
     int partofvoice[NVOICES]; */ /* which part has triggered each "voice";
                                -1 (should we use zero instead?) means
                                that the voice is free to re-occupy. */

  /* FIXME: Remove this, too:
     synti2_patch *patchofvoice[NVOICES];*/  /* which patch is sounding; */

  //synti2_part part[NPARTS];   /* FIXME: I want to call this channel!!!*/





  /* note on */

  /* FIXME: Unimplemented plan: if patch is monophonic, always use the
   * voice corresponding to the part number. Otherwise, if that
   * primary voice is occupied, find a free voice starting from index
   * 17. This way, there is always one voice available per channel for
   * mono patches, and it will become more deterministic to know where
   * things happen, for possible visualization needs (but there is
   * evil resource wasting when the song uses less than 16 parts!
   * maybe some kind of free voice stack could be implemented with not
   * too much code...)
   */
  for(voice=0; voice < NVOICES-1; voice++){
    if (s->partofvoice[voice] < 0) break;
  }
  /*if (voice==NVOICES) return;*/ /* Cannot play new note! */
  /* (Could actually force the last voice to play anyway!?) */




Just some lessons learned:

/** Interprets command line.
 *
 * TODO: Implement this; so far only example code from the GNU manual.
 *
 * TODO (later): learn to use argp instead of getopt..
 */
static
void
misssify_options_parse(misssify_options *opt, int argc, char *argv[]){
  int c;
  static int local_verbose; /* must know address on compile time. */
  /* Defaults for some values:*/
  strncpy(opt->outfname, "test.misss", MAX_STRINGLENGTH);
  /* Aah, but this will only fail possibly for user input:
  if (strlen(str) >= MAX_STRINGLENGTH){
    fprintf(stderr, "File path too long. %s", str);
    exit(0);
  }
  */
  opt->infname[0]='\0';

  while (1){
    static struct option long_options[] =
      {
        /* These options set a flag. */
        {"verbose", no_argument,       &local_verbose, 1},
        {"brief",   no_argument,       &local_verbose, 0},
        /* These options don't set a flag.
           We distinguish them by their indices. */
        {"add",     no_argument,       0, 'a'},
        {"append",  no_argument,       0, 'b'},
        {"delete",  required_argument, 0, 'd'},
        {"velocity-all",  required_argument, 0, 'l'},
        {"only-on", no_argument, 0, 'o'},
        {"tpq",     required_argument, 0, 'p'},
        {0, 0, 0, 0} /* marks the end of options */
      };
    /* getopt_long stores the option index here. */
    int option_index = 0;
    
    c = getopt_long (argc, argv, "ab:d:l:op:",
                     long_options, &option_index);
    
    /* Detect the end of the options. */
    if (c == -1)
      break;
    
    switch (c)
      {
      case 0:
        /* If this option set a flag, do nothing else now. */
        if (long_options[option_index].flag != 0)
          break;
        printf ("option %s", long_options[option_index].name);
        if (optarg)
          printf (" with arg %s", optarg);
        printf ("\n");
        break;
        
      case 'a':
        puts ("option -a\n");
        break;
        
      case 'b':
        puts ("option -b\n");
        break;
        
      case 'c':
        printf ("option -c with value `%s'\n", optarg);
        break;
        
      case 'd':
        printf ("option -d with value `%s'\n", optarg);
        break;

      case 'l':
        opt->override_all_velocities = atoi(optarg);
        printf ("All velocities will be %d (given as string '%s')\n", 
                opt->override_all_velocities, optarg);
        break;

      case 'o':
        opt->trash_all_noteoffs = 1;
        printf ("No note-offs will be written on *any* part. \n");
        break;
        
      case 'p':
        opt->desired_timediv = atoi(optarg);
        printf ("Desired timediv is %d (given as string '%s')\n", 
                opt->desired_timediv, optarg);
        break;
        
      case '?':
        /* getopt_long already printed an error message. */
        break;
        
      default:
        abort ();
      }
  }
  
  /* Instead of reporting ‘--verbose’
     and ‘--brief’ as they are encountered,
     we report the final status resulting from them. */
  opt->verbose = local_verbose;
  if (opt->verbose){
    fprintf(stderr, "Verbose on. I'll start talking to stderr.\n");
  }
  
  /* Remaining command line arguments (not options); we must have
     input file name. */
  if (optind >= argc){
    fprintf(stderr, "Input file name must be given!\n");
    exit(0);
  }
  if (strlen(argv[optind]) >= MAX_STRINGLENGTH){
    fprintf(stderr, "Input file path too long. Will use default! %s\n", argv[argc]);
  } else {
    strncpy(opt->infname, argv[optind], MAX_STRINGLENGTH);
  }

  /* Can have output file name. */
  optind++;
  if (optind >= argc){
    return;
  }
  if (strlen(argv[optind]) >= MAX_STRINGLENGTH){
    fprintf(stderr, "Output file path too long. Will use default! %s\n", argv[argc]);
  } else {
    strncpy(opt->outfname, argv[optind], MAX_STRINGLENGTH);
  }
}


Regarding modularity and size:

   * FIXME: I already let go of all dynamic allocations for the sake
   * 4k.. Maybe just move the few attributes of the player to be
   * attributes of the synth itself.. Yes, the latter would be the
   * most lean (and mean) option for a 4k synth, I guess. No... this
   * turned out to be untrue, at least when just trying out in the
   * most obvious way.
