Old contemplations of formats and stuff..
-----------------------------------------

#
# As of now (2012-04-11), the sound algorithm is finally almost
# finished for synti2. Only some things related to stereo panning and
# delay effect routing is still lacking from the original plan/dream. 
# And then some other things... but not too many changes anyway.
#
#
# Global data (to be planned)
#   TODO: *Can we use the same int3/int7/float -structure for global data
#         and for patches. Simplifies reader maybe.. "Patch 0"== global
#
#   Ideas:
#
#   Patch selection on each channel/part (range 0-127?)?:
#   0   0   0   0   0   0   0   0   0   0 
#   0   0   0   0   0   0
#
#   Could be done with normal program change messages!?
#     --> Yes, and the "midi filter module" would intercept this, 
#         if somebody

# Mixer section? --> No.. There is now a MIX_LEVEL per patch.
#  (It is just a GUI issue if this feature is needed)
# Volume -> Mix
# 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
# 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0

# Volume -> Effect1  --> No.. There are no special effects in synti2
# 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
# 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0

# Volume -> Effect2  --> No.. There are no special effects in synti2
# 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
# 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0

# Pan?  --> No.. There is now a pan parameter per patch.
#  (It is just a GUI issue if this feature is needed)
# 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
# 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0

# Global parameters would be something like:
#  Delay1                       Delay2
#  length  feedback  LPcutoff   length  feedback  LPcutoff

# Or... should the effects be abstracted as "imaginary part 17" etc.?
#   Could be, of course! 
#   But for now, let us just use some of the MIDI channels for these




# TODO: Think if there should be a "global envelope bank"? Noo.. would
# be too different from a "usual synth interface" which I want to aim
# at (in addition to any other goals).. Maybe in a later project(!).

 * DONE: Controllers would sound nicer if they were clamping counters
 * (no artefacts from discrete value jumps)
 *


#ifndef NO_SYSEX_RECEIVE
    } else if (midibuf[0] == MISSS_MSG_DATA){
      /* Receiving SysEx is nice, but not strictly necessary if the
       * initial patch data is given upon creation.
       */
      synti2_do_receiveData(s, midibuf+1);
#endif

/*
 * Misss data format ideas 
 * (Old, deprecated, banished)
 *
 * <songheader> <layer>+
 * <layer> = <layerheader> <layerdata>
 * <layerheader> = <length> <tickmultiplier> <type> <part#> <parameters>
 * <layerdata> = <event>+
 * <event> = <delta><byte>+
 *
 * ... more or less so... and... 
 *
 * Types of layers:
 *
 *  [- 0x8 note off
 *        <delta>  -- maybe unnecessary if using vel=0 for note off!]
 *  - 0x9 note on with variable velocity
 *        <delta><note#><velocity>
 *  - 0x1 note on with constant velocity (given as a parameter)
 *        (note off encoded as on with constant velocity==0)
 *        <delta><note#>
 *  - 0x2 note on with constant pitch (given as a parameter)
 *        <delta><velocity>
 *  - 0x3 note on with constant pitch and velocity (given as parameters)
 *        <delta>
 *
 *  OR... TODO: think if note on and note velocity could be separated?
 *              suppose they could.. could have accented beats and
 *              velocity ramps with little-ish overhead?
 *
 *  - 0xB controller instantaneous
 *        <delta><value>
 *  - 0x4 controller ramp from-to/during
 *        <delta><value1><delta2><value2>
 *  [- 0x5 pitch bend ramp from-to/during (or re-use controller ramp?
 *        DEFINITELY! because our values can be var-length which is 
 *        very natural for pitch bend MSB when needed..)
 *        <delta><bend1><delta2><bend2>]
 *  - 0xf sysex
 *        <delta><sysex>
 *
 *  - 0x6 0x7 0xA 0xC 0xD 0xE reserved. 0x5 probably too.
 *    Maybe could use the 4th bit of type nibble for something else?
 *
 *  Type and part fit in one byte.
 */



The design specification of MisssChunk classes (to be replaced with
proper documentation):
  // Something like this for creation;
  //void from_midi_song_using_translator(MidiSong &s, MidiTranslator &mt);
  // maybe sniff_note_ons_from_channel(MidiSong &s, MidiTranslator &mt, chan);
  /* Or maybe in OOP style just something like:

     setAcceptChn(12);   <- superclass
     Type("Note on"),  <- subclass, actually maybe class MisssNoteChunk
     setNoteAcceptRange("1..32"); <- in MisssNoteChunk only
     setConstantNote(24); <- in MisssNoteChunk!! Wow! THIS determines subtype
     setConstantNote(-1); <- in MisssNoteChunk!! becomes other subtype..
     setConstantVel(100); <- in MisssNoteChunk!! Wow! THIS determines subtype
     setVelAcceptRange(90,110); <- in MisssNoteChunk! THIS is the decimation!
     setVelAcceptRange(1,127); <- and THIS is "no note off" subtype!

     setAcceptController(32); <- in MisssRampChunk only
     setOutputRange(0.0, 1.27); <- in MisssRampChunk only

     Then play back once through translator and each chunk goes
     sniffing for their respective food:

     for each chunk:
       if (chunk.eat_if_tasty(midievent)) break;

     Then MisssRampChunk could have nice algorithms for ramp
     determination, and MisssBulkChunk would be just another, simpler,
     subclass. 

       rampchunk.setDelta() <- THIS is the generative delta which fits
       in the two-byte parameters. OH NO! It doesn't.. need a third
       byte (maybe.. think!) But there could be three for this chunk
       and still only two for the others. It's only an if and add in
       the exe anyway.

       rampchunk.setExaminationTime() <- parameters for the linear
       approximation can be set like this.

     MisssChunk could be a virtual superclass, and Misss file creation
     would become just a matter of building a chunk list from a GUI
     button callback. Oh, but it needs to be serializable. So all
     these will have constructors with a string parameter:

       MisssNoteChunk nc1("Chn: 1 VelRange: 1 127 DefVel: -1 DefNote: -1");
       MisssNoteChunk nc2("Chn: 2 VelRange: 0 127 DefVel: -1 DefNote: -1");
       MisssNoteChunk nc3("Chn: 1 VelRange: 0 0 DefVel: 0 DefNote: -1");

     YES!! Do exactly this. FIXME: asap!!!
  */
  // or something like: from_midi_song_picking_only("chn 1 note on");


The old inner loop thingy:

/* Number of inner loop iterations (audio frame evaluations) between
 * evaluating "slow-motion stuff" such as MIDI input and
 * envelopes. Must be a divisor of the buffer length. Example: 48000/8
 * would yield 6000 Hz (or faster than midi wire rate) responsiveness.
 * Hmm.. there is an audible problem with "jagged volume" (producing a
 * pitched artefact) if the amplitude envelope is outside of the inner
 * loop... So I'll keep at least the envelope progression counter code
 * inside. Same must be true for panning which is essentially an amplitude
 * env. Could it be that pitch or filter envelopes could be outside?
 * TODO: test..
 *
 * As a second thought, I finally think that for 4k/tiny stuff it
 * would be best to not separate the inner loop at all. The
 * performance hit could be compensated by other means in composition
 * mode, and in playback mode we can have a longer output buffer in
 * any case. So the actual to-do is to merge the inner loop to the
 * outer one, maintaining real-time capacity in composition mode.
 */
#define NINNERLOOP 1


The old MISSS spec:

/** MISSS - Midi-like interface for Synti2 Software Synthesizer.
 *
 * This program reads and analyzes a standard MIDI file (type 0 or
 * type 1), tries to mutilate it in various ways to reduce its size,
 * and outputs a file compatible with the super-simplistic sequencer
 * part of the Synti2 Software Synthesizer.
 *
 * FIXME: I want to redo this with some more flexible programming
 * language.. (DONE: used C++)
 *
 * Ideas:
 *
 * + Trash all events that Synti2 doesn't handle.
 *
 * + Use simplistic note-off (not going to use note-off velocity)
 *
 * + Make exactly one "track" - call it "layer"! - per one MIDI status
 *   word, use the channel nibble of the status byte for something
 *   more useful (which is? Could be "chord size", i.e., number of
 *   instantaneous notes, no need for zero delta!), and write
 *   everything as "running status". Make a very simple layering
 *   algorithm to piece it together upon sequencer creation. Just "for
 *   layer in layers do song.addlayer(layer)" and then start
 *   playing. Will be very simple at that point.
 *
 * + Trash header information that Synti2 doesn't need.
 *
 * + Only one BPM value allowed throughout the song; no tempo map,
 *   sry. (No need to compute much during the playback).
 *
 * + Use lower parts-per-quarter setting, and quantize notes as
 *   needed. The variable-length delta idea is useful as it is.
 *   FIXME: Could I re-use the var-length decoder for the patches???
 *   I think I could, somehow... if I just figured out how...
 *
 * - Decimate velocities
 *
 * - Approximate controllers with linear ramps.
 *
 * - Turn percussion tracks to binary beat patterns(?).
 *
 * - Observe: Percussive instruments need no note-off.
 *
 */


In the old comment of receiveSysEx()...

/** FIXME: Think about data model.. aim at maximal
    sparsity/compressibility but sufficient expressive range. If it
    turns out that the 1/1000 accuracy is very seldom required, then
    it could be worthwhile to store everything in the much simpler
    format of 4*7 = 28-bit signed integer representing (decimal)
    hundredths. Even then most parameters would only have the
    least-significant 7bit set?

    FIXME: If the song sequence data is finally read from SMF, then
    there will already be a subroutine that reads variable length
    values (the time deltas) which could be re-used here. But what
    about accuracy then?

    FIXME: Think about nonlinear parameter range. For example x^2 -
    usually accuracy is critical for the smaller parameter values. But
    no... pitch envelopes need to be accurate on a wide range!!

    FIXME: Think about the following format:

            high       low
      bits: 000 0000   000 0000
            ||| ||||   |
            ||| ||||   initial value, 7 bits, range 0.000 to 0.127
            ||| ||additional 2 bits? -> integer range 0..511
            ||| ||TODO: could have a third bit? range 0..1024! Wow!
            ||| ||
            ||times to multiply by 10 (range -1270k to +1270; acc. 10000)
            |reserved FIXME: no need to reserve! 
            sign

      examples of usual bit patterns:
            000 0000   000 0001   == 0.001
            100 0000   000 0001   == -0.001
            000 0100   110 0100   == 1.00
            000 0100   000 0000   == 0.00


    SysEx format (planned; FIXME: implement!) 

    F0 00 00 00 [storeAddrMSB] [storeAddrLSB] [inputLengthMSB] [inputLengthLSB]
    ... data LLSBs... 
    ... data LMSBs... 
    ... data MLSBs... 
    ... data MMSBs... 
    F7

    Length is also the stride for value encoding.
**/

Old code for 2-byte F pars:

  //for (c=((a & 0x0c) >> 2); c < 3; c++) decoded *= .1f; /* e-N; N=0..2) */
  //for (c=0; c < ((a & 0x0c) >> 2); c++) decoded *= .1f; /* can be more */
  //decoded *= .001f;                           /* default e-3 */
  //for (c=0; c < ((a & 0x0c) >> 2); c++) decoded *= 10.f; /* can be more */
  /*use of powf() seems to yield longer exe..*/
  /*decoded *= powf(10.f, ((a & 0x0c) >> 2)-3);*/
  /*pat->fpar[ir] = decoded * powf(10.f, ((a & 0x0c) >> 2)-3.f);*/



Old Makefile parts:
-------------------

tinyplayer: $(TINYPLAYERDEPS) Makefile
	$(CC) $(HCFLAGS) $(ARCHFLAGS) -o $@.unstripped.payload \
		-combine -fwhole-program -flto \
		-Iinclude \
		-DULTRASMALL -nostdlib  -nostartfiles -lc \
		$(filter %.c, $(TINYPLAYERDEPS)) \
		$(ARCHLIBS)

	cp $@.unstripped.payload $@.payload 
	$(ARCHSTRIP) $(ARCHSTRIPOPT) $@.payload
	7za a -tgzip -mx=9 tmp.gz $@.payload
	cat tests/selfextr.stub tmp.gz > $@
	rm tmp.gz
	chmod ugo+x $@

# For some reason at least -msse4 seems to shave bytes.. so it is
# worthwhile to keep the following memories. I used the following the
# last time.. but there were some stability problems with the compo
# machine...

# -fno-strict-aliasing \
#          -ffast-math -fomit-frame-pointer \
#	  -fpredictive-commoning \
#          --param max-unroll-times=0 \
#          --param max-unrolled-insns=0 \
#          -msse4 -mavx -mhard-float 


tinytest: $(SDLTESTDEPS) tests/selfextr.stub Makefile
# hacking
#
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) `sdl-config --cflags` -c -o sdltest.o sdltest.c 
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) -c -o synti2.o synti2.c
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) -c -o testdata.o testdata.c
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) -c -o teh4k_gfx.o teh4k_gfx.c

#	$(CC) $(ARCHFLAGS) -o $@.unstripped.payload sdltest.o synti2.o testdata.o \
		teh4k_gfx.o \
	   -nostartfiles $(LIBS)

	$(CC) $(HCFLAGS) $(ARCHFLAGS) -o $@.unstripped.payload \
		-combine -fwhole-program -flto \
		-Iinclude \
		-DULTRASMALL -nostdlib  -nostartfiles -lc \
		$(filter %.c, $(SDLTESTDEPS)) \
		$(ARCHLIBS)

# Why do I get problems with these and -m32:
# `sdl-config --libs` -lm -lGL -lGLU


#	$(CC) $(ARCHFLAGS) -o $@.unstripped.payload sdltest.o synti2.o testdata.o \
#		teh4k_gfx.o \
#	   -nostartfiles `sdl-config --libs` -lm -lGL -lGLU

#	strip $(STRIPOPT) -o $@.payload $@.unstripped.payload
#	cat selfextr.stub > $@
#	gzip -n9 <$@.payload >> $@

# I got a 32-bit sstrip executable from Zipola :).  The zipped result
# got from 4.3k down to 3.8k by compiling with -m32 and linking
# against 32bit libraries, using 7zip, and stripping with sstrip
# instead of strip:
	cp $@.unstripped.payload $@.payload 

	$(ARCHSTRIP) $(ARCHSTRIPOPT) $@.payload

	7za a -tgzip -mx=9 tmp.gz $@.payload
	cat tests/selfextr.stub tmp.gz > $@
	rm tmp.gz

	chmod ugo+x $@


sdltest: $(SDLTESTDEPS) Makefile
	$(CC) $(CFLAGS) -o $@ -Iinclude \
		$(filter %.c , $(SDLTESTDEPS)) \
	   `sdl-config --cflags --libs` -lm -lGL -lGLU




Old snippets whose function was moved away from the core engine are
kept here, for purposes of reflection...

  /* The parts. Sixteen as in the MIDI standard. TODO: Could have more? */
  /* FIXME: Remove for good:
     int partofvoice[NVOICES]; */ /* which part has triggered each "voice";
                                -1 (should we use zero instead?) means
                                that the voice is free to re-occupy. */

  /* FIXME: Remove this, too:
     synti2_patch *patchofvoice[NVOICES];*/  /* which patch is sounding; */

  //synti2_part part[NPARTS];   /* FIXME: I want to call this channel!!!*/





  /* note on */

  /* FIXME: Unimplemented plan: if patch is monophonic, always use the
   * voice corresponding to the part number. Otherwise, if that
   * primary voice is occupied, find a free voice starting from index
   * 17. This way, there is always one voice available per channel for
   * mono patches, and it will become more deterministic to know where
   * things happen, for possible visualization needs (but there is
   * evil resource wasting when the song uses less than 16 parts!
   * maybe some kind of free voice stack could be implemented with not
   * too much code...)
   */
  for(voice=0; voice < NVOICES-1; voice++){
    if (s->partofvoice[voice] < 0) break;
  }
  /*if (voice==NVOICES) return;*/ /* Cannot play new note! */
  /* (Could actually force the last voice to play anyway!?) */




Just some lessons learned:

/** Interprets command line.
 *
 * TODO: Implement this; so far only example code from the GNU manual.
 *
 * TODO (later): learn to use argp instead of getopt..
 */
static
void
misssify_options_parse(misssify_options *opt, int argc, char *argv[]){
  int c;
  static int local_verbose; /* must know address on compile time. */
  /* Defaults for some values:*/
  strncpy(opt->outfname, "test.misss", MAX_STRINGLENGTH);
  /* Aah, but this will only fail possibly for user input:
  if (strlen(str) >= MAX_STRINGLENGTH){
    fprintf(stderr, "File path too long. %s", str);
    exit(0);
  }
  */
  opt->infname[0]='\0';

  while (1){
    static struct option long_options[] =
      {
        /* These options set a flag. */
        {"verbose", no_argument,       &local_verbose, 1},
        {"brief",   no_argument,       &local_verbose, 0},
        /* These options don't set a flag.
           We distinguish them by their indices. */
        {"add",     no_argument,       0, 'a'},
        {"append",  no_argument,       0, 'b'},
        {"delete",  required_argument, 0, 'd'},
        {"velocity-all",  required_argument, 0, 'l'},
        {"only-on", no_argument, 0, 'o'},
        {"tpq",     required_argument, 0, 'p'},
        {0, 0, 0, 0} /* marks the end of options */
      };
    /* getopt_long stores the option index here. */
    int option_index = 0;
    
    c = getopt_long (argc, argv, "ab:d:l:op:",
                     long_options, &option_index);
    
    /* Detect the end of the options. */
    if (c == -1)
      break;
    
    switch (c)
      {
      case 0:
        /* If this option set a flag, do nothing else now. */
        if (long_options[option_index].flag != 0)
          break;
        printf ("option %s", long_options[option_index].name);
        if (optarg)
          printf (" with arg %s", optarg);
        printf ("\n");
        break;
        
      case 'a':
        puts ("option -a\n");
        break;
        
      case 'b':
        puts ("option -b\n");
        break;
        
      case 'c':
        printf ("option -c with value `%s'\n", optarg);
        break;
        
      case 'd':
        printf ("option -d with value `%s'\n", optarg);
        break;

      case 'l':
        opt->override_all_velocities = atoi(optarg);
        printf ("All velocities will be %d (given as string '%s')\n", 
                opt->override_all_velocities, optarg);
        break;

      case 'o':
        opt->trash_all_noteoffs = 1;
        printf ("No note-offs will be written on *any* part. \n");
        break;
        
      case 'p':
        opt->desired_timediv = atoi(optarg);
        printf ("Desired timediv is %d (given as string '%s')\n", 
                opt->desired_timediv, optarg);
        break;
        
      case '?':
        /* getopt_long already printed an error message. */
        break;
        
      default:
        abort ();
      }
  }
  
  /* Instead of reporting ‘--verbose’
     and ‘--brief’ as they are encountered,
     we report the final status resulting from them. */
  opt->verbose = local_verbose;
  if (opt->verbose){
    fprintf(stderr, "Verbose on. I'll start talking to stderr.\n");
  }
  
  /* Remaining command line arguments (not options); we must have
     input file name. */
  if (optind >= argc){
    fprintf(stderr, "Input file name must be given!\n");
    exit(0);
  }
  if (strlen(argv[optind]) >= MAX_STRINGLENGTH){
    fprintf(stderr, "Input file path too long. Will use default! %s\n", argv[argc]);
  } else {
    strncpy(opt->infname, argv[optind], MAX_STRINGLENGTH);
  }

  /* Can have output file name. */
  optind++;
  if (optind >= argc){
    return;
  }
  if (strlen(argv[optind]) >= MAX_STRINGLENGTH){
    fprintf(stderr, "Output file path too long. Will use default! %s\n", argv[argc]);
  } else {
    strncpy(opt->outfname, argv[optind], MAX_STRINGLENGTH);
  }
}
