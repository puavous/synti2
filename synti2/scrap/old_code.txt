Old contemplations of formats and stuff..
-----------------------------------------

The design specification of MisssChunk classes (to be replaced with
proper documentation):




In the old comment of receiveSysEx()...

/** FIXME: Think about data model.. aim at maximal
    sparsity/compressibility but sufficient expressive range. If it
    turns out that the 1/1000 accuracy is very seldom required, then
    it could be worthwhile to store everything in the much simpler
    format of 4*7 = 28-bit signed integer representing (decimal)
    hundredths. Even then most parameters would only have the
    least-significant 7bit set?

    FIXME: If the song sequence data is finally read from SMF, then
    there will already be a subroutine that reads variable length
    values (the time deltas) which could be re-used here. But what
    about accuracy then?

    FIXME: Think about nonlinear parameter range. For example x^2 -
    usually accuracy is critical for the smaller parameter values. But
    no... pitch envelopes need to be accurate on a wide range!!

    FIXME: Think about the following format:

            high       low
      bits: 000 0000   000 0000
            ||| ||||   |
            ||| ||||   initial value, 7 bits, range 0.000 to 0.127
            ||| ||additional 2 bits? -> integer range 0..511
            ||| ||TODO: could have a third bit? range 0..1024! Wow!
            ||| ||
            ||times to multiply by 10 (range -1270k to +1270; acc. 10000)
            |reserved FIXME: no need to reserve! 
            sign

      examples of usual bit patterns:
            000 0000   000 0001   == 0.001
            100 0000   000 0001   == -0.001
            000 0100   110 0100   == 1.00
            000 0100   000 0000   == 0.00


    SysEx format (planned; FIXME: implement!) 

    F0 00 00 00 [storeAddrMSB] [storeAddrLSB] [inputLengthMSB] [inputLengthLSB]
    ... data LLSBs... 
    ... data LMSBs... 
    ... data MLSBs... 
    ... data MMSBs... 
    F7

    Length is also the stride for value encoding.
**/

Old code for 2-byte F pars:

  //for (c=((a & 0x0c) >> 2); c < 3; c++) decoded *= .1f; /* e-N; N=0..2) */
  //for (c=0; c < ((a & 0x0c) >> 2); c++) decoded *= .1f; /* can be more */
  //decoded *= .001f;                           /* default e-3 */
  //for (c=0; c < ((a & 0x0c) >> 2); c++) decoded *= 10.f; /* can be more */
  /*use of powf() seems to yield longer exe..*/
  /*decoded *= powf(10.f, ((a & 0x0c) >> 2)-3);*/
  /*pat->fpar[ir] = decoded * powf(10.f, ((a & 0x0c) >> 2)-3.f);*/



Old Makefile parts:
-------------------

tinyplayer: $(TINYPLAYERDEPS) Makefile
	$(CC) $(HCFLAGS) $(ARCHFLAGS) -o $@.unstripped.payload \
		-combine -fwhole-program -flto \
		-Iinclude \
		-DULTRASMALL -nostdlib  -nostartfiles -lc \
		$(filter %.c, $(TINYPLAYERDEPS)) \
		$(ARCHLIBS)

	cp $@.unstripped.payload $@.payload 
	$(ARCHSTRIP) $(ARCHSTRIPOPT) $@.payload
	7za a -tgzip -mx=9 tmp.gz $@.payload
	cat tests/selfextr.stub tmp.gz > $@
	rm tmp.gz
	chmod ugo+x $@



tinytest: $(SDLTESTDEPS) tests/selfextr.stub Makefile
# hacking
#
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) `sdl-config --cflags` -c -o sdltest.o sdltest.c 
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) -c -o synti2.o synti2.c
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) -c -o testdata.o testdata.c
#	$(CC) $(HCFLAGS) $(ARCHFLAGS) -c -o teh4k_gfx.o teh4k_gfx.c

#	$(CC) $(ARCHFLAGS) -o $@.unstripped.payload sdltest.o synti2.o testdata.o \
		teh4k_gfx.o \
	   -nostartfiles $(LIBS)

	$(CC) $(HCFLAGS) $(ARCHFLAGS) -o $@.unstripped.payload \
		-combine -fwhole-program -flto \
		-Iinclude \
		-DULTRASMALL -nostdlib  -nostartfiles -lc \
		$(filter %.c, $(SDLTESTDEPS)) \
		$(ARCHLIBS)

# Why do I get problems with these and -m32:
# `sdl-config --libs` -lm -lGL -lGLU


#	$(CC) $(ARCHFLAGS) -o $@.unstripped.payload sdltest.o synti2.o testdata.o \
#		teh4k_gfx.o \
#	   -nostartfiles `sdl-config --libs` -lm -lGL -lGLU

#	strip $(STRIPOPT) -o $@.payload $@.unstripped.payload
#	cat selfextr.stub > $@
#	gzip -n9 <$@.payload >> $@

# I got a 32-bit sstrip executable from Zipola :).  The zipped result
# got from 4.3k down to 3.8k by compiling with -m32 and linking
# against 32bit libraries, using 7zip, and stripping with sstrip
# instead of strip:
	cp $@.unstripped.payload $@.payload 

	$(ARCHSTRIP) $(ARCHSTRIPOPT) $@.payload

	7za a -tgzip -mx=9 tmp.gz $@.payload
	cat tests/selfextr.stub tmp.gz > $@
	rm tmp.gz

	chmod ugo+x $@


sdltest: $(SDLTESTDEPS) Makefile
	$(CC) $(CFLAGS) -o $@ -Iinclude \
		$(filter %.c , $(SDLTESTDEPS)) \
	   `sdl-config --cflags --libs` -lm -lGL -lGLU




Old snippets whose function was moved away from the core engine are
kept here, for purposes of reflection...

  /* The parts. Sixteen as in the MIDI standard. TODO: Could have more? */
  /* FIXME: Remove for good:
     int partofvoice[NVOICES]; */ /* which part has triggered each "voice";
                                -1 (should we use zero instead?) means
                                that the voice is free to re-occupy. */

  /* FIXME: Remove this, too:
     synti2_patch *patchofvoice[NVOICES];*/  /* which patch is sounding; */

  //synti2_part part[NPARTS];   /* FIXME: I want to call this channel!!!*/





  /* note on */

  /* FIXME: Unimplemented plan: if patch is monophonic, always use the
   * voice corresponding to the part number. Otherwise, if that
   * primary voice is occupied, find a free voice starting from index
   * 17. This way, there is always one voice available per channel for
   * mono patches, and it will become more deterministic to know where
   * things happen, for possible visualization needs (but there is
   * evil resource wasting when the song uses less than 16 parts!
   * maybe some kind of free voice stack could be implemented with not
   * too much code...)
   */
  for(voice=0; voice < NVOICES-1; voice++){
    if (s->partofvoice[voice] < 0) break;
  }
  /*if (voice==NVOICES) return;*/ /* Cannot play new note! */
  /* (Could actually force the last voice to play anyway!?) */
