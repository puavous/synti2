#ifndef MIDITOOL_H_INCLUDED
#define MIDITOOL_H_INCLUDED

/** Classes for processing MIDI and MISSS sequences and events, either
 * in real-time or off-line.
 *
 */

#include "jack/midiport.h"

#define MIDI_NCHANNELS 16
#define MIDI_NNOTES 128

#include <map>
#include <string>
#include <iostream>

typedef unsigned int miditick_t;
typedef unsigned char evdata_t;


/** MidiSong can read a standard midi file, and iterate it (call it
 *  "playback" if you wish) one event at a time.
 */
class MidiSong {
  std::map<miditick_t, evdata_t *> evs;
  MidiSong(const char *fname){;}
};

/** MisssSong can sniff a MidiSong using a MidiTranslator and save a
 * MISSS (midi-like interface for synti2 software synthesizer) data
 * package as C-language source code, directly compilable into a 4k
 * intro, as the main use case of this programming excercise was.
 */
class MisssSong {
private:
public:
  void write_as_c(std::ostream &outs){
    outs << "/*Song data generated by MisssSong */" << std::endl;
    outs << "#include \"synti2_misss.h\"" << std::endl;
    outs << "unsigned char hacksong_data[] = {" << std::endl;
    outs << "/* *********** song header *********** */ " << std::endl;
    outs << "/* Ticks per quarter :        */ 0x0c," << std::endl;
    outs << "/* Microseconds per quarter : */ 0xa0, 0xc2, 0x1e," << std::endl;
    outs << "/* *********** chunks *********** */ " << std::endl;
    outs << std::endl;
    outs << "/* CHUNK: hack try -- basedrum on 4beat */ " << std::endl;
    outs << "/* Number of events in this chunk: */ 0x10," << std::endl;
    outs << "/* Channel of this chunk: */ 0x09," << std::endl;
    outs << "/* Type    of this chunk: */ MISSS_LAYER_NOTES_CVEL_CPITCH," << std::endl;
    outs << "/* Parameter 1 (Ex. note): */ 48," << std::endl;
    outs << "/* Parameter 2 (Ex. vel): */ 127," << std::endl;
    outs << "/* delta and info : */ " << std::endl;
    outs << "   12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12," << std::endl;
    outs << std::endl;
    outs << "/* CHUNK: hack try -- basedrum on 4beat */ " << std::endl;
    outs << "/* Number of events in this chunk: */ 0x10," << std::endl;
    outs << "/* Channel of this chunk: */ 0x0a," << std::endl;
    outs << "/* Type    of this chunk: */ MISSS_LAYER_NOTES_CVEL_CPITCH," << std::endl;
    outs << "/* Parameter 1 (Ex. note): */ 48," << std::endl;
    outs << "/* Parameter 2 (Ex. vel): */ 127," << std::endl;
    outs << "/* delta and info : */ " << std::endl;
    outs << "   18,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12," << std::endl;



    outs << "/* *********** end *********** */ " << std::endl;
    outs << "/* End of data marker: */ 0x00};" << std::endl;
  };
};

/** The translator eats a standard midi message, and pukes an altered
 *  message based on loaded configuration and current state. (TODO: as
 *  midi or as missss?). Doesn't care if it is working in a real-time
 *  or off-line job, it just answers when a question is asked.
 */
class MidiEventTranslator {
private:
  int voice_rotate[MIDI_NCHANNELS];
  int next_rotation[MIDI_NCHANNELS];
  int rotation_of_noteon[MIDI_NCHANNELS][MIDI_NNOTES];
  int note_of_rotation[MIDI_NCHANNELS][MIDI_NCHANNELS];
  int channel_table[MIDI_NCHANNELS][MIDI_NNOTES];

  /** default settings; FIXME: to be removed after proper accessors exist. 
   */
  void hack_defaults();
  /** Reset everything.. FIXME: This should mean a bit different thing.. */
  void reset_state();
public:
  MidiEventTranslator();
  int rotate_notes(jack_midi_event_t *ev);
  void channel(jack_midi_event_t *ev);

};

#endif
